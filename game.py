import numpy as np # импорт numpy под псевдонимом np

def game_core_v4(number): # назначаем функцию с параметром number (загаданное число)
    count = 0 # задаем стартовое число попыток: 0
    predict = np.random.randint(1,100) # сначала называем случайное число от 1 до 100 (используя метод из numpy)
    # predict - это текущая попытка угадать число (не номер попытки, а число-попытка)

#     newlist = [] # подсмотрено в чужом коде, не использовалось
#     for i in range(1, 101): # подсмотрено в чужом коде, не использовалось
#         newlist.append(i) # подсмотрено в чужом коде, не использовалось

    # задаем нижнюю и верхнюю границы - для подсчета методом деления пополам
    low = 0 # нижняя граница
    high = 101 # верхняя граница
    
    while number != predict: # цикл с условием: он выполняется, пока загаданное число не станет равно числу-попытке
        count+=1 # увеличиваем счетчит попыток на 1
        predict = (low + high) // 2 # если не угадали число с 1й попытки, то будем выяснять с помощью данной формулы:
        # суммируем нижнюю и верхнюю границу и делим сумму на 2. Присваевам результат переменной predict (попытке)
        # из
        
        # print(predict) # для наглядности во время теста
        
        if number > predict: # если загаданное число больше текущего числа-попытки
            low = predict # нижняя граница становится равной текущему числу-попытке
            # (т. к. загаданное число точно не будет меньше текущего числа-попытки)
        elif number < predict: # иначе если загаданное число меньше текущего числа-попытки
            high = predict # верхняя граница становится равной текущему числу-попытке
            # (т. к. загаданное число точно не будет больше текущего числа-попытки)
    return(count) # выход из цикла, если угадали
    
    # логика
#     1. загадывается число number
#     2. называется случайное число-попытка predict
#     3. если не угадали, то число-попытка становится равной сумме нижней и верхней границы, поделенной на 2 (сначала это (0+100) // 2 = 50)
#     4. если число меньше или больше загаданного, то нижняя/верхняя границы становятся равными числу-попытке
#     5. значит, меняется и само число-попытка (т. к. оно зависит от значений нижней и верхней границ)
#     6. следующая итерация уже будет принимать в рассчет измененное число-попытку и тд., пока путем деления на 2 не будет найдено загаданное число
#     7. выход из цикла и возвращение значение count (число попыток угадывания - они считались в цикле)

# print(f'число попыток: {game_core_v2(1)}') для наглядности во время теста

# здесь код не менялся, кроме названия 1й функции
def score_game(game_core_v4):
    '''Запускаем игру 1000 раз, чтоб узнать как быстро игра угадывает число'''
    count_ls = []
    np.random.seed(1)  # фиксируем RANDOM SEED, чтобы ваш эксперимент был воспроизводим!
    random_array = np.random.randint(1, 101, size=(1000))
    for number in random_array:
        count_ls.append(game_core_v4(number))
    score = int(np.mean(count_ls))
    print(f"Ваш алгоритм угадывает число в среднем за {score} попыток")
    return(score)

score_game(game_core_v4)